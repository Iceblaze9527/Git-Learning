# 2.2 保存更改
> ✍️ [童仲毅](https://github.com/geeeeeeeeek)  |  ⏳ 2018 年 10 月 26 日（部分章节未更新）
>
> ©️ 本文演绎自 Atlassian 编写的 [_Saving Changes_](https://www.atlassian.com/git/tutorials/saving-changes)。页面上所有内容采用知识共享-署名（[CC BY 2.5 AU](http://creativecommons.org/licenses/by/2.5/au/deed.zh)）许可协议。

## 2.2.0 本节指令 
1. `git add`
2. `git commit`
3. `git diff`
4. `git stash`
5. `.gitignore`

## 2.2.1 概述
在 Git 中，提交（commit）这个操作作用于若干个文件和目录。Git 提交可以在本地完成，然后再使用`git push -u origin master`命令推送到远端服务器。

`git add`、`git status`和`git commit`这三个命令通常一起使用，将 Git 项目当前的状态保存成一份快照。

Git 还有另一个保存机制：“储藏”（stash）。储藏是一个临时的储存区域，保存还没准备好提交的更改。储藏操作作用于工作目录，三个文件树中的第一棵。它有很多用法。

Git 仓库可以通过设置忽略一些文件或目录。Git 将不会保存这些文件的任何更改。Git 有多种方式管理忽略文件列表。

## 2.2.2 git add
`git add` 命令将工作目录中的变化添加到暂存区。它告诉 Git 你想要在下一次提交时包含这个文件的更新。但是，`git add` 不会实质上地影响你的仓库——在你运行 `git commit` 前更改都还没有真正被记录。

使用这些命令的同时，你还需要 `git status` 来查看工作目录和暂存区的状态。

### 2.2.2.1 用法

```
git add <file>
```
将 `<file>` 中的更改加入下次提交的缓存。
```
git add <directory>
```
将 `<directory>` 下的更改加入下次提交的缓存。
```
git add -i
git add -p(二者有细微差别)
```
开始交互式的缓存，你可以选择文件的一部分加入到下次提交缓存。它会向你展示一堆更改，等待你输入一个命令。`y` 将这块更改加入缓存，`n` 忽略这块更改，`s` 将它分割成更小的块，`e` 手动编辑这块更改，以及 `q` 退出。

### 2.2.2.2 讨论
`git add` 和 `git commit` 这两个命令组成了最基本的 Git 工作流。每一个 Git 用户都需要理解这两个命令，不管他们团队的协作模型是如何的。有一千种方式可以将项目版本记录在仓库的历史中。

例如在一个只有编辑、缓存、提交这样基本流程的项目上开发。首先，你要在工作目录中编辑你的文件。当你准备备份项目的当前状态时，你通过 `git add` 来缓存更改。当你对缓存的快照满意之后，你通过 `git commit` 将它提交到你的项目历史中去。

![Git Tutorial: git add Snapshot](https://wac-cdn.atlassian.com/dam/jcr:0f27e004-f2f5-4890-921d-65fa77ba2774/01.svg)
 `git add` 发生于更抽象的 *更改* 层面。也就是说，`git add` 在每次你修改一个文件时都需要被调用，这听上去很多余，但这样的工作流使得一个项目更容易组织。

### 2.2.2.3 缓存区
缓存允许你在实际提交到项目历史之前，将相关的更改组合成一份高度集中的快照，而不是将你上次提交以后产生的所有更改一并提交。也就是说你可以更改各种不相关的文件，然后回过去将它们按逻辑切分，将相关的更改添加到缓存，一份一份提交。在任何修改控制系统中，很重要的一点是提交必须是atomic，以便于追踪 bug，并用最小的代价回滚更改。

### 2.2.2.4 例子
```
git add .
git commit
```
当你项目设置好之后，新的文件可以通过路径传递给 `git add` 来添加：
```
git add hello.py
git commit
```
上面的命令同样可以用于记录已有文件的更改。重复一次，Git 不会区分缓存的更改来自新文件，还是仓库中已有的文件。

## 2.2.3 git commit
`git commit`命令将缓存的快照提交到项目历史。提交的快照可以认为是项目安全的版本，Git 永远不会改变它们，除非你这么要求。和 `git add` 一样，这是最重要的 Git 命令之一。快照被提交到本地仓库，不会和其他 Git 仓库有任何交互。

### 2.2.3.1 用法
```
git commit
```
提交已经缓存的快照。它会运行文本编辑器，等待你输入提交信息。当你输入信息之后，保存文件，关闭编辑器，创建实际的提交。
```
git commit -m "<message>"
```
提交已经缓存的快照。但将 `<message>` 作为提交信息，而不是运行文本编辑器。
```
git commit -a
```
提交一份包含工作目录所有更改的快照。它只包含那些之前已经通过 `git add` 添加过的文件。
```
git commit -am "<message>"
```
高级用户快捷方式命令，它结合了`-a`和`-m`选项。 此组合会立即创建所有暂存更改的提交，并采用内联提交消息。
```
git commit --amend
```
此选项为commit命令添加了另一级功能。 传递该参数将修改上次提交而不是创建新的提交，更改将添加到以前的提交。 此命令将打开系统配置的文本编辑器，并提示更改先前指定的提交信息。
```
```

### 2.2.3.2 讨论
快照总是提交到 *本地* 仓库。就像缓存区是工作目录和项目历史之间的缓冲地带，每个开发者的本地仓库是他们贡献的代码和中央仓库之间的缓冲地带。

这一点改变了 Git 用户基本的开发模型。Git 开发者可以在本地仓库中积累一些提交，而不是一发生更改就直接提交到中央仓库。这对于 SVN 风格的协作有着诸多优点：更容易将功能切分成原子性的提交，让相关的提交组合在一起，发布到中央仓库之前整理好本地的历史。开发者得以在一个隔离的环境中工作，直到他们方便的时候再整合代码。

### 2.2.3.3 记录快照，而不是记录差异
 Git 的版本控制模型基于 *快照* 。一个 SVN 提交由仓库中原文件相比的差异（diff）组成。而 Git 在每次提交中记录文件的 *完整内容* 。

![Git Tutorial: Snapshots, Not Differences](https://www.atlassian.com/dam/jcr:7406fe56-d36d-44cf-92e3-b28e4bae36f8/02.svg)

这让很多 Git 操作比 SVN 来的快得多，因为文件的某个版本不需要通过版本间的差异组装得到——每个文件完整的修改能立刻从 Git 的内部数据库中得到。

Git 的快照模型对它版本控制模型的方方面面都有着深远的影响，从分支到合并工具，再到协作工作流，以至于影响了所有特性。

### 2.2.3.4 例子
下面这个例子假设你编辑了 `hello.py` 文件的一些内容，并且准备好将它提交到项目历史。首先，你需要用 `git add` 缓存文件，然后提交缓存的快照。
```
git add hello.py
git commit
```
它会打开一个文件编辑器（可以通过 `git config` 设置) 询问提交信息，同时列出将被提交的文件。
```
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
# (use "git reset HEAD <file>..." to unstage)
#
#modified: hello.py
```
Git 对提交信息没有特定的格式限制，但约定俗成的格式是：在第一行用 50 个以内的字符总结这个提交，留一空行，然后详细阐述具体的更改。比如：
```
Change the message displayed by hello.py

- Update the sayHello() function to output the user's name
- Change the sayGoodbye() function to a friendlier message
```
注意，很多开发者倾向于在提交信息中使用一般现在时态。这样看起来更像是对仓库进行的操作，让很多改写历史的操作更加符合直觉。

## 2.2.4 git diff
`diffing`是一个函数，它接收两个输入数据集并输出它们之间的变化。 `git diff`是一个多用途的Git命令，在执行时会在Git数据源上运行diff函数。 这些数据源可以是`commit`，`branch`，`file`等。 

本节将讨论`git diff`和`diffing`工作流模式的常见调用。 

`git diff`命令通常与`git status`和`git log`用于分析Git repo的当前状态。

### 2.2.4.1 用法

```shell
git diff
```

#### 输出结果：

```shell
diff --git a/diff_test.txt b/diff_test.txt
index 6b0c6cf..b37e70a 100644
--- a/diff_test.txt
+++ b/diff_test.txt
@@ -1 +1 @@
-this is a git diff test example
+this is a diff example
```

#### 解释说明：
1. 比较输入
```shell
diff --git a/diff_test.txt b/diff_test.txt
```
该行显示`diff`的输入源。 我们可以看到`a/diff_test.txt`和`b/diff_test.txt`已传递给`diff`。

2. 元数据
```shell
index 6b0c6cf..b37e70a 100644
```
此行显示一些内部Git元数据。 你很可能不需要此信息。 此输出中的数字对应于Git对象版本哈希标识符。

3. 更改标记
```shell
--- a/diff_test.txt 
+++ b/diff_test.txt
```
这些线是一个图例，用于为每个diff输入源分配符号。 在这种情况下，来自`a/diff_test.txt`的更改用`---`标记，而`b/diff_test.txt`的更改用`+++`符号标记。

4. 差异块
```
@@ -1 +1 @@ 
-this is a git diff test example 
+this is a diff example
```
剩余的`diff`输出是`diff 'chunk'`列表。 `diff`仅显示具有更改的文件部分。  块有自己的输出语义。

第一行是块头。 每个块前面都有一个包含在`@@`符号内的标题。 标题的内容是对文件所做更改的摘要。 在我们的简化示例中，我们有-1 + 1意味着第一行有变化。 在更现实的差异中，你会看到如下标题：
```
@@ -34,6 +34,8 @@
```
在该标题示例中，从行号34开始提取了6行。另外，从行号34开始添加了8行。
```
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTIwNjUzMTk1MCwtMzI1NTM1MzEzLC0xOT
I4ODYzNzUwLC05MzAxMTM2NiwtMjg0MzM4Mjg2LDE5MzI5Mjg2
NTIsLTUxNjI0NTUzMF19
-->